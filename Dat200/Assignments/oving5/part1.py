# -*- coding: utf-8 -*-


"""Assignment5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/141obMsqOx5b7O1FJtygf0x3WEgkssl79

# Assignment #5

Hash Tables in Python


In this assignment, you will create Python dictionaries from scratch using a data structure called hash table. For example, here's a dictionary for storing and retrieving phone numbers using people's numbers.
"""

phone_numbers = {
'3316412003': 'Waqar Bilal',
'3033226026': 'Hamza Zia',
'3032217073': 'Abid Zahid'
}


"""**Part 1**: Your objective in this assignment is to implement a “My_HashTable class” that supports the following operations:

•	Insert: Insert a new key-value pair

•	Search: Find the value associated with a key

•	Update: Update the value associated with a key

•	display_all: List all the keys stored in the hash table

Complete the hash table implementation below by following the instructions in the comments.

 (30 p)
"""
print("Part 1 \n")

class MyHashTable:
    def __init__(self):

        # 1. Create a list of size `list_size` with all values None
        self.max_size = 4096
        self.list_size = [None for i in range(self.max_size)]

    def get_hash(self,key):
        # write simple algorithm for hashing, which can convert strings into numeric list indices.
        # Iterate over the string, character by character Convert each character to a number using Python's built-in ord function.
        # Add the numbers for each character to obtain the hash for the entire string
        # Take the remainder of the result with the size of the data list
        # Variable to store the result (updated after each iteration)

        hash_value = 0
        for char in key:
            hash_value = ord(char)
        return hash_value % self.max_size



    def get_index(self, key):
        # Take the remainder of the hash value with the size of the data list and return the index
        hash_value = self.get_hash(key)
        index = hash_value % self.max_size
        return index

    def insert(self, key, value):
        # 1. Find the index for the key using get_index
        index = self.get_index(key)
        # 2. Store the key-value pair at the right index
        if self.list_size[index] is None:
            self.list_size[index] = []
        self.list_size[index].append((key, value))

    def search(self, key):
        # 1. Find the index for the key using get_index
        index = self.get_index(key)

        # 2. Retrieve the data stored at the index
        data_at_index = self.list_size[index]

        # 3. Return the value if found, else return None
        if data_at_index is not None:
            for item in data_at_index:
                if item[0] == key:
                    return item[1]
        return None

    def update(self, key, value):
        # 1. Find the index for the key using get_index
        index = self.get_index(key)

        # 2. Store the new key-value pair at the right index
        if self.list_size[index] is not None:
            for i, item in enumerate(self.list_size[index]):
                if item[0] == key:
                    self.list_size[index][i] = (key, value)

    def display_all(self):
        # Extract all key-value pairs
        all_key_value_pairs = []
        for index in self.list_size:
            if index is not None:
                all_key_value_pairs.extend(index)
        return all_key_value_pairs


my_hash_table = MyHashTable()

# Insert the key-value pairs
my_hash_table.insert('3316412003', 'Waqar Bilal')
my_hash_table.insert('3033226026', 'Hamza Zia')
my_hash_table.insert('3032217073', 'Abid Zahid')
print("Name for number: ",my_hash_table.search('3033226026'), "\n")

search_key = '3033226026'
index = my_hash_table.get_index(search_key)
print(f"Index for number {search_key}: {index}\n")


# Display all key-value pairs
all_key_value_pairs = my_hash_table.display_all()
for item in all_key_value_pairs:
    print(f"Key: {item[0]}, Value: {item[1]}")


"""**Part2:** Read the phonebook CSV file and store the key/value data in the hashtable object created in the “My_HashTable class”, hashtable size is : max_size =4096

* take phone column as the key
* take the name column as the value

 (10 p)
"""

# write your code here
print("\nPart 2 \n")


import csv

hash_table = MyHashTable()

with open('Dat200/Assignments/oving5/Phonebook.csv', 'r') as file:
    csv_reader = csv.DictReader(file)
    for row in csv_reader:
        phone_number = row['phone']
        name = row['name']
        hash_table.insert(phone_number, name)

all_key_value_pairs = hash_table.display_all()
for item in all_key_value_pairs:
    print(f"Key: {item[0]}, Value: {item[1]}")


"""**Part 3:** try to add these two new data into the created hashtable:


phone_number_1 = '123456789', name_1 = 'UiS'

phone_number_2 = '987654321', name_2 = 'NTNU'


•	Explain what happened there when you add the second number???

 (10 p)


"""
print("\nPart 3 \n")

 

phone_number_1 = '123456789'
name_1 = 'UiS'

phone_number_2 = '987654321'
name_2 = 'NTNU'

my_hash_table.insert(phone_number_1, name_1)
my_hash_table.insert(phone_number_2, name_2)

# Display all key-value pairs
all_key_value_pairs = my_hash_table.display_all()
for item in all_key_value_pairs:
    print(f"Key: {item[0]}, Value: {item[1]}")



"""**Part 4:**
Handling Collisions with Linear Probing: As you might have wondered, multiple keys can have the same hash.

Data stored against one key may override the data stored against another, if they have the same hash.

* So Define a function called get_valid_index, which starts searching the data list from the index determined by the hashing function get_index and returns the first index which is either empty or contains a key-value pair matching the given key. Here you implement the linear probing method to find the available slot and return the index.


* now implement a hash table class with linear probing. You need to define a  "ProbingHashTable" class.
* add get_valid_index function into the ProbingHashTable class

* Implement all the operations for this class: Insert,Search,Update, display_all


 (40 p)



"""
print("\nPart 4 \n")



#def get_valid_index(data_list, key):
#    # Start with the index returned by get_index

class ProbingHashTable:
    def __init__(self):

        # 1. Create a list of size `list_size` with all values None
        self.max_size = 4096
        self.data = [None] * self.max_size


    def get_valid_index(self,key):
        index = self.get_index(key)

        # Check if the index is empty or contains a key matching the given key
        while self.data[index] is not None and self.data[index][0] != key:
            # Linear probing: Move to the next index
            index = (index + 1) % self.max_size

        return index


    def get_hash(self,key):
        # write simple algorithm for hashing, which can convert strings into numeric list indices.
        # Iterate over the string, character by character Convert each character to a number using Python's built-in ord function.
        # Add the numbers for each character to obtain the hash for the entire string
        # Take the remainder of the result with the size of the data list
        # Variable to store the result (updated after each iteration)
        hash_value = 0
        for char in key:
            hash_value = ord(char)
        return hash_value % self.max_size



    def get_index(self, key):
        # Take the remainder of the result with the size of the data list and return the index of the list
        return self.get_hash(key)

    def insert(self, key, value):
        # 1. Find the index for the key using get_index
        index = self.get_valid_index(key)
        
        # 2. Store the key-value pair at the right index
        self.data[index] = (key, value)

    def search(self, key):
        # 1. Find the index for the key using get_index

        index = self.get_valid_index(key)
        
        # 2. Retrieve the data stored at the index
        if self.data[index] is not None and self.data[index][0] == key:
            return self.data[index][1]
        

        # 3. Return the value if found, else return None
        return None

    def update(self, key, value):
        # 1. Find the index for the key using get_index
        index = self.get_valid_index(key)
        
        # 2. Store the new key-value pair at the right index
        if self.data[index] is not None and self.data[index][0] == key:
            self.data[index] = (key, value)

    def display_all(self):
        # 1. Extract the key from each key-value pair
        
        all_key_value_pairs = [item for item in self.data if item is not None]
        return all_key_value_pairs

"""read csv file and store the data into a hashtable object"""

# write your code here

probing_hash_table = ProbingHashTable()

# Insert the key-value pairs
probing_hash_table.insert('3316412003', 'Waqar Bilal')
probing_hash_table.insert('3033226026', 'Hamza Zia')
probing_hash_table.insert('3032217073', 'Abid Zahid')

# Display all key-value pairs



"""Try to add two new numbers and test
 (10 p)
"""

phone_number_1 = '911'
name_1 = 'Police'

phone_number_2 = '911'
name_2 = 'Politiet'

#insert the first key

probing_hash_table.insert(phone_number_1, name_1)

all_key_value_pairs = probing_hash_table.display_all()
for item in all_key_value_pairs:
    print(f"Key: {item[0]}, Name: {item[1]}")


# Insert a colliding key

probing_hash_table.insert(phone_number_2, name_2)

# Check the new and old keys

all_key_value_pairs = probing_hash_table.display_all()
for item in all_key_value_pairs:
    print(f"Key: {item[0]}, Name: {item[1]}")